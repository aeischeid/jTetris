/* 
  PROCESSINGJS.COM
  Native Processing compatible 
*/  

// Global variables
int X, Y, nX, nY; 
float easing = 0.4;
Piece currentPiece, nextPiece;
PShape s;

// Setup the Processing Canvas
void setup(){
  // Set canvas size
  size( 240, 500 );
  strokeWeight( 1 );
  frameRate( 30 );
  //set where pieces begin to drop from
  startX = (width/2); 
  startY = 10;
  X = (width / 2) -10;
  Y = 5;
  
  
  rectMode(CENTER);
  s1 = loadShape("data/long.svg");
  s2 = loadShape("data/t.svg");
  
  currentPiece = new Piece();
  nextPiece = new Piece();
}

// Main draw loop
void draw(){
  // Fill canvas grey - have to do in draw loop to draw over old piece position
  background( 100 );
  
/*  shape(s1, 40, 40, 80, 20);*/
/*  shape(s2, 100, 100, 60, 40);*/
  
  // Draw rect
  currentPiece.display()
}

void keyPressed() {
  println("pressed " + key + " " + keyCode);
  // 37,38,39,40 correspond to left,up,right,down
  if(keyCode == 37){
    currentPiece.move(-20,0);
  }
  if(keyCode == 39){
    currentPiece.move(20,0);
  }
  if(keyCode == 38){
    currentPiece.turn();
  }
  if(keyCode == 40){
    currentPiece.move(0,20);
  }
}

class Piece
{
  int shape, h, w; //
  float xpos, ypos, rotation, nRotation; // x & y position, new and old rotation angles
  
 
  Piece() {
    //shape = int(random(1,4);
    //getShape(shape);
    h = 20;
    w = 80;
    rotation = 0.0;
    nRotation = 0.0;
    xpos = startX;
    ypos = startY;
  }
 
  void move(int posX, int posY) {
    xpos += posX;
    ypos += posY;
  }
  
  void turn() {
    nRotation += HALF_PI;
  }
  
/*  void getShape(int shape){*/
/*    switch(shape){*/
/*      case 1:*/
/*        rect(50,5,20,20);*/
/*        break;*/
/*      case 2:*/
/*        rect(50,5,20,40);*/
/*        break;*/
/*      case 3:*/
/*        rect(50,5,20,60);*/
/*        break;*/
/*      case 4:*/
/*        rect(50,5,40,40);*/
/*        break;*/
/*      default:*/
/*        */
/*    }*/
/*  }*/
  
  void display() {
    // Set fill-color to blue
    fill( 0, 121, 184 );
    // Move
    translate(xpos, ypos);
    // animate the rotation
    if(nRotation > rotation){
      float dif = nRotation - rotation;
      if(abs(dif) > 0.2) {
        rotation += dif * easing;
      }
      else {
        rotation = nRotation;
      }
    }
    rotate(rotation);
    shapeMode(CORNERS);
    beginShape();
    vertex(0, 0);
    vertex(20, 0);
    vertex(20, 20);
    vertex(40, 20);
    vertex(40, 40);
    vertex(0, 40);
    endShape(CLOSE);
/*    // Set stroke-color white*/
/*    stroke(255);*/
/*    rect(0, 0, w, h);*/
  }
}

